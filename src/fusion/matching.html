<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!--  This file is generated by Nim. -->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- Favicon -->
<link rel="shortcut icon" href="data:image/x-icon;base64,AAABAAEAEBAAAAEAIABoBAAAFgAAACgAAAAQAAAAIAAAAAEAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AAAAAAUAAAAF////AP///wD///8A////AP///wD///8A////AP///wD///8A////AAAAAAIAAABbAAAAlQAAAKIAAACbAAAAmwAAAKIAAACVAAAAWwAAAAL///8A////AP///wD///8A////AAAAABQAAADAAAAAYwAAAA3///8A////AP///wD///8AAAAADQAAAGMAAADAAAAAFP///wD///8A////AP///wAAAACdAAAAOv///wD///8A////AP///wD///8A////AP///wD///8AAAAAOgAAAJ3///8A////AP///wAAAAAnAAAAcP///wAAAAAoAAAASv///wD///8A////AP///wAAAABKAAAAKP///wAAAABwAAAAJ////wD///8AAAAAgQAAABwAAACIAAAAkAAAAJMAAACtAAAAFQAAABUAAACtAAAAkwAAAJAAAACIAAAAHAAAAIH///8A////AAAAAKQAAACrAAAAaP///wD///8AAAAARQAAANIAAADSAAAARf///wD///8AAAAAaAAAAKsAAACk////AAAAADMAAACcAAAAnQAAABj///8A////AP///wAAAAAYAAAAGP///wD///8A////AAAAABgAAACdAAAAnAAAADMAAAB1AAAAwwAAAP8AAADpAAAAsQAAAE4AAAAb////AP///wAAAAAbAAAATgAAALEAAADpAAAA/wAAAMMAAAB1AAAAtwAAAOkAAAD/AAAA/wAAAP8AAADvAAAA3gAAAN4AAADeAAAA3gAAAO8AAAD/AAAA/wAAAP8AAADpAAAAtwAAAGUAAAA/AAAA3wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAADfAAAAPwAAAGX///8A////AAAAAEgAAADtAAAAvwAAAL0AAADGAAAA7wAAAO8AAADGAAAAvQAAAL8AAADtAAAASP///wD///8A////AP///wD///8AAAAAO////wD///8A////AAAAAIcAAACH////AP///wD///8AAAAAO////wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A//8AAP//AAD4HwAA7/cAAN/7AAD//wAAoYUAAJ55AACf+QAAh+EAAAAAAADAAwAA4AcAAP5/AAD//wAA//8AAA=="/>
<link rel="icon" type="image/png" sizes="32x32" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAA3XAAAN1wFCKJt4AAAAB3RJTUUH4QQQEwksSS9ZWwAAAk1JREFUWMPtll2ITVEUx39nn/O7Y5qR8f05wtCUUr6ZIS++8pEnkZInPImneaCQ5METNdOkeFBKUhMPRIkHKfEuUZSUlGlKPN2TrgfncpvmnntnmlEyq1Z7t89/rf9a6+y99oZxGZf/XeIq61EdtgKXgdXA0xrYAvBjOIF1AI9zvjcC74BSpndrJPkBWDScTF8Aa4E3wDlgHbASaANmVqlcCnwHvgDvgVfAJ+AikAAvgfVZwLnSVZHZaOuKoQi3ZOMi4NkYkpe1p4J7A8BpYAD49hfIy/oqG0+hLomiKP2L5L+1ubn5115S+3OAn4EnwBlgMzCjyt6ZAnQCJ4A7wOs88iRJHvw50HoujuPBoCKwHWiosy8MdfZnAdcHk8dxXFJ3VQbQlCTJvRBCGdRbD4M6uc5glpY3eAihpN5S5w12diSEcCCEcKUO4ljdr15T76ur1FDDLIQQ3qv71EdDOe3Kxj3leRXyk+pxdWnFWod6Wt2bY3de3aSuUHcPBVimHs7mK9WrmeOF6lR1o9qnzskh2ar2qm1qizpfXaPeVGdlmGN5pb09qMxz1Xb1kLqgzn1RyH7JUXW52lr5e/Kqi9qpto7V1atuUzfnARrV7jEib1T76gG2qxdGmXyiekkt1GswPTtek0aBfJp6YySGBfWg2tPQ0FAYgf1stUfdmdcjarbYJEniKIq6gY/Aw+zWHAC+p2labGpqiorFYgGYCEzN7oQdQClN07O1/EfDyGgC0ALMBdYAi4FyK+4H3gLPsxfR1zRNi+NP7nH5J+QntnXe5B5mpfQAAAAASUVORK5CYII=">

<!-- Google fonts -->
<link href='https://fonts.googleapis.com/css?family=Lato:400,600,900' rel='stylesheet' type='text/css'/>
<link href='https://fonts.googleapis.com/css?family=Source+Code+Pro:400,500,600' rel='stylesheet' type='text/css'/>

<!-- CSS -->
<title>src/fusion/matching</title>
<link rel="stylesheet" type="text/css" href="../../nimdoc.out.css">

<script type="text/javascript" src="../../dochack.js"></script>

<script type="text/javascript">
function main() {
  var pragmaDots = document.getElementsByClassName("pragmadots");
  for (var i = 0; i < pragmaDots.length; i++) {
    pragmaDots[i].onclick = function(event) {
      // Hide tease
      event.target.parentNode.style.display = "none";
      // Show actual
      event.target.parentNode.nextElementSibling.style.display = "inline";
    }
  }

  const toggleSwitch = document.querySelector('.theme-switch input[type="checkbox"]');
  function switchTheme(e) {
      if (e.target.checked) {
          document.documentElement.setAttribute('data-theme', 'dark');
          localStorage.setItem('theme', 'dark');
      } else {
          document.documentElement.setAttribute('data-theme', 'light');
          localStorage.setItem('theme', 'light');
      }
  }

  toggleSwitch.addEventListener('change', switchTheme, false);

  const currentTheme = localStorage.getItem('theme') ? localStorage.getItem('theme') : null;
  if (currentTheme) {
    document.documentElement.setAttribute('data-theme', currentTheme);

    if (currentTheme === 'dark') {
      toggleSwitch.checked = true;
    }
  }
}

window.addEventListener('DOMContentLoaded', main);
</script>

</head>
<body>
<div class="document" id="documentId">
  <div class="container">
    <h1 class="title">src/fusion/matching</h1>
    <div class="row">
  <div class="three columns">
  <div class="theme-switch-wrapper">
    <label class="theme-switch" for="checkbox">
      <input type="checkbox" id="checkbox" />
      <div class="slider round"></div>
    </label>
    &nbsp;&nbsp;&nbsp; <em>Dark Mode</em>
  </div>
  <div id="global-links">
    <ul class="simple">
    <li>
      <a href="../../theindex.html">Index</a>
    </li>
    </ul>
  </div>
  <div id="searchInputDiv">
    Search: <input type="text" id="searchInput"
      onkeyup="search()" />
  </div>
  <div>
    Group by:
    <select onchange="groupBy(this.value)">
      <option value="section">Section</option>
      <option value="type">Type</option>
    </select>
  </div>
  <ul class="simple simple-toc" id="toc-list">
<li><a class="reference" id="use-example_toc" href="#use-example">Use example</a></li>
<li><a class="reference" id="quick-reference_toc" href="#quick-reference">Quick reference</a></li>
<li><a class="reference" id="supported-match-elements_toc" href="#supported-match-elements">Supported match elements</a></li>
<li><a class="reference" id="element-access_toc" href="#element-access">Element access</a></li>
<li><a class="reference" id="checks_toc" href="#checks">Checks</a></li>
<ul class="simple"><li><a class="reference" id="checks-examples_toc" href="#checks-examples">Examples</a></li>
</ul><li><a class="reference" id="variable-binding_toc" href="#variable-binding">Variable binding</a></li>
<ul class="simple"><li><a class="reference" id="variable-binding-bind-order_toc" href="#variable-binding-bind-order">Bind order</a></li>
<li><a class="reference" id="variable-binding-bind-variable-type_toc" href="#variable-binding-bind-variable-type">Bind variable type</a></li>
</ul><li><a class="reference" id="matching-different-things_toc" href="#matching-different-things">Matching different things</a></li>
<ul class="simple"><li><a class="reference" id="matching-different-things-sequence-matching_toc" href="#matching-different-things-sequence-matching">Sequence matching</a></li>
<li><a class="reference" id="matching-different-things-tuple-matching_toc" href="#matching-different-things-tuple-matching">Tuple matching</a></li>
<li><a class="reference" id="matching-different-things-case-object-matching_toc" href="#matching-different-things-case-object-matching">Case object matching</a></li>
<li><a class="reference" id="matching-different-things-ref-object-matching_toc" href="#matching-different-things-ref-object-matching">Ref object matching</a></li>
<li><a class="reference" id="matching-different-things-kvminuspairs-matching_toc" href="#matching-different-things-kvminuspairs-matching">KV-pairs matching</a></li>
<li><a class="reference" id="matching-different-things-option-matching_toc" href="#matching-different-things-option-matching">Option matching</a></li>
</ul><li><a class="reference" id="tree-construction_toc" href="#tree-construction">Tree construction</a></li>
<li>
  <a class="reference reference-toplevel" href="#7" id="57">Types</a>
  <ul class="simple simple-toc-section">
      <li><a class="reference" href="#FieldIndex"
    title="FieldIndex = distinct int">FieldIndex</a></li>
  <li><a class="reference" href="#MatchKind"
    title="MatchKind = enum
  kItem,                    ## Match single element
  kSeq,                     ## Match sequence of elements
  kTuple,                   ## Mach tuple (anonymous or named)
  kPairs,                   ## Match key-value pairs
  kObject,                  ## Match object, named tuple or object-like value
  kSet,                     ## Match set of elements
  kAlt                       ## Ordered choice - mactch any of patterns.">MatchKind</a></li>
  <li><a class="reference" href="#SeqKeyword"
    title="SeqKeyword = enum
  lkAny = &quot;any&quot;,            ## Any element from seq
  lkAll = &quot;all&quot;,            ## All elements from seq
  lkNone = &quot;none&quot;,          ## None of the elements from seq
  lkOpt = &quot;opt&quot;,            ## Optionaly match element in seq
  lkUntil = &quot;until&quot;,        ## All elements until
  lkPref = &quot;pref&quot;,          ## All elements while
  lkPos,                    ## Exact position
  lkSlice,                  ## Subrange slice
  lkTrail                    ## Variadic placeholder `.._`">SeqKeyword</a></li>
  <li><a class="reference" href="#SeqStructure"
    title="SeqStructure = object
  decl: NimNode              ## Original declaration of the node
  bindVar*: Option[NimNode]  ## Optional bound variable
  patt*: Match               ## Patterh for element matching
  case kind*: SeqKeyword
  of lkSlice:
      slice*: NimNode

  else:
      nil">SeqStructure</a></li>
  <li><a class="reference" href="#ItemMatchKind"
    title="ItemMatchKind = enum
  imkInfixEq,               ## Match item using infix operator
  imkSubpatt,               ## Match item by checking it agains subpattern
  imkPredicate               ## Execute custom predicate to determine if element
                             ## matches pattern.">ItemMatchKind</a></li>
  <li><a class="reference" href="#KVPair"
    title="KVPair = object
  key: NimNode
  patt: Match">KVPair</a></li>
  <li><a class="reference" href="#MatchError"
    title="MatchError = ref object of CatchableError">MatchError</a></li>
  <li><a class="reference" href="#Match"
    title="Match = ref object
  bindVar*: Option[NimNode]  ## Bound variable (if any)
  declNode*: NimNode         ## Original declaration of match
  isOptional*: bool
  fallback*: Option[NimNode] ## Default value in case match fails
  case kind*: MatchKind
  of kItem:
      case itemMatch: ItemMatchKind
      of imkInfixEq:
          infix*: string     ## Infix operator used for comparison
          rhsNode*: NimNode  ## Rhs expression to compare against
          isPlaceholder*: bool ## Always true? `_` pattern is an
                               ## infix expression with `isPlaceholder` equal to true
        
      of imkSubpatt:
          rhsPatt*: Match    ## Subpattern to compare value against
        
      of imkPredicate:
          isCall*: bool      ## Predicate is a call expression
                             ## (`@val.matches()`) or a free-standing expression
                             ## (`@val(it.len &lt; 100)`)
          predBody*: NimNode ## Body of the expression
        
    
  of kAlt:
      altElems*: seq[Match]  ## Alternatives for matching
    
  of kSeq:
      seqElems*: seq[SeqStructure] ## Sequence subpatterns
    
  of kTuple:
      tupleElems*: seq[Match] ## Tuple elements
    
  of kPairs:
      pairElems*: seq[KVPair]
      nocheck*: bool

  of kSet:
      setElems*: seq[Match]

  of kObject:
      kindCall*: Option[NimNode] ## Optional node with kind
                                 ## expression pattern (see `hasKind`)
      isRefKind*: bool
      fldElems*: seq[tuple[name: string, patt: Match]]
      kvMatches*: Option[Match] ## Optional key-value matches for
                                ## expressions like `JObject({&quot;key&quot;: @val})`
      seqMatches*: Option[Match] ## Optional indexed matches for
                                 ## subelement access using `Infix([@op, @lhs, @rhs])` pattern.">Match</a></li>
  <li><a class="reference" href="#VarKind"
    title="VarKind = enum
  vkRegular,                ## Regular variable, assigned once
  vkSequence, vkOption, vkSet, vkAlt">VarKind</a></li>
  <li><a class="reference" href="#VarSpec"
    title="VarSpec = object
  decl*: NimNode             ## First time variable has been declared
  case varKind*: VarKind     ## Type of the variable
  of vkAlt:
      prefixMap*: Table[Path, AltSpec]

  else:
      nil

  typePath*: Path            ## Whole path for expression that can be used to
                             ## determine type of the variable.
  cnt*: int                  ## Number of variable occurencies in expression">VarSpec</a></li>

  </ul>
</li>
<li>
  <a class="reference reference-toplevel" href="#10" id="60">Consts</a>
  <ul class="simple simple-toc-section">
      <li><a class="reference" href="#nnkStrKinds"
    title="nnkStrKinds = {nnkStrLit..nnkTripleStrLit}">nnkStrKinds</a></li>
  <li><a class="reference" href="#nnkIntKinds"
    title="nnkIntKinds = {nnkCharLit..nnkUInt64Lit}">nnkIntKinds</a></li>
  <li><a class="reference" href="#nnkFloatKinds"
    title="nnkFloatKinds = {nnkFloatLit..nnkFloat128Lit}">nnkFloatKinds</a></li>
  <li><a class="reference" href="#nnkIdentKinds"
    title="nnkIdentKinds = {nnkIdent, nnkSym, nnkOpenSymChoice}">nnkIdentKinds</a></li>
  <li><a class="reference" href="#nnkTokenKinds"
    title="nnkTokenKinds = {nnkEmpty..nnkSym, nnkCharLit..nnkTripleStrLit, nnkOpenSymChoice}">nnkTokenKinds</a></li>

  </ul>
</li>
<li>
  <a class="reference reference-toplevel" href="#12" id="62">Procs</a>
  <ul class="simple simple-toc-section">
      <ul class="simple nested-toc-section">addPrefix
      <li><a class="reference" href="#addPrefix%2Cstring%2Cstring"
    title="addPrefix(str, pref: string): string">addPrefix,<wbr>string,<wbr>string</a></li>

  </ul>
  <ul class="simple nested-toc-section">getKindNames
      <li><a class="reference" href="#getKindNames%2CNimNode"
    title="getKindNames(head: NimNode): (string, seq[string])">getKindNames,<wbr>NimNode</a></li>

  </ul>
  <ul class="simple nested-toc-section">parseMatchExpr
      <li><a class="reference" href="#parseMatchExpr%2CNimNode"
    title="parseMatchExpr(n: NimNode): Match">parseMatchExpr,<wbr>NimNode</a></li>

  </ul>
  <ul class="simple nested-toc-section">toAccs
      <li><a class="reference" href="#toAccs%2CPath%2CNimNode%2Cbool"
    title="toAccs(path: Path; name: NimNode; pathForType: bool): NimNode">toAccs,<wbr>Path,<wbr>NimNode,<wbr>bool</a></li>

  </ul>
  <ul class="simple nested-toc-section">str
      <li><a class="reference" href="#str%2CNimNode"
    title="str(node: NimNode): string">str,<wbr>NimNode</a></li>

  </ul>
  <ul class="simple nested-toc-section">kind=
      <li><a class="reference" href="#kind%3D%2CNimNode%2CNimNodeKind"
    title="kind=(node: var NimNode; kind: NimNodeKind)">kind=,<wbr>NimNode,<wbr>NimNodeKind</a></li>

  </ul>
  <ul class="simple nested-toc-section">makeMatchExpr
      <li><a class="reference" href="#makeMatchExpr%2CMatch%2CNimNode%2Cbool%2CNimNode"
    title="makeMatchExpr(m: Match; mainExpr: NimNode; doRaise: bool;
              originalMainExpr: NimNode): tuple[expr: NimNode, vtable: VarTable,
    mixident: seq[string]]">makeMatchExpr,<wbr>Match,<wbr>NimNode,<wbr>bool,<wbr>NimNode</a></li>

  </ul>
  <ul class="simple nested-toc-section">==
      <li><a class="reference" href="#%3D%3D%2CFieldIndex%2CSomeInteger"
    title="`==`(idx: FieldIndex; i: SomeInteger): bool">==,<wbr>FieldIndex,<wbr>SomeInteger</a></li>

  </ul>
  <ul class="simple nested-toc-section">str=
      <li><a class="reference" href="#str%3D%2CNimNode%2Cstring"
    title="str=(node: var NimNode; val: string)">str=,<wbr>NimNode,<wbr>string</a></li>

  </ul>

  </ul>
</li>
<li>
  <a class="reference reference-toplevel" href="#17" id="67">Macros</a>
  <ul class="simple simple-toc-section">
      <li><a class="reference" href="#hasKindImpl.m%2Ctyped%2Cuntyped"
    title="hasKindImpl(head: typed; kind: untyped): untyped">hasKindImpl</a></li>
  <li><a class="reference" href="#expand.m%2Ctyped"
    title="expand(body: typed): untyped">expand</a></li>
  <li><a class="reference" href="#match.m%2Cuntyped"
    title="match(n: untyped): untyped">match</a></li>
  <li><a class="reference" href="#assertMatch.m%2Cuntyped%2Cuntyped"
    title="assertMatch(input, pattern: untyped): untyped">assertMatch</a></li>
  <li><a class="reference" href="#matches.m%2Cuntyped%2Cuntyped"
    title="matches(input, pattern: untyped): untyped">matches</a></li>

  </ul>
</li>
<li>
  <a class="reference reference-toplevel" href="#18" id="68">Templates</a>
  <ul class="simple simple-toc-section">
      <li><a class="reference" href="#varOfIteration.t%2Cuntyped"
    title="varOfIteration(arg: untyped): untyped">varOfIteration</a></li>
  <li><a class="reference" href="#findItFirstOpt.t%2Ctyped%2Cuntyped"
    title="findItFirstOpt(s: typed; op: untyped): untyped">findItFirstOpt</a></li>
  <li><a class="reference" href="#hasKind.t%2Cuntyped%2Cuntyped"
    title="hasKind(head, kindExpr: untyped): untyped">hasKind</a></li>
  <li><a class="reference" href="#%5B%5D.t%2C%2Cstatic%5BFieldIndex%5D"
    title="`[]`(t: tuple; idx: static[FieldIndex]): untyped">`[]`</a></li>
  <li><a class="reference" href="#makeTree.t%2Ctyped%2Cuntyped"
    title="makeTree(T: typed; patt: untyped): untyped">makeTree</a></li>
  <li><a class="reference" href="#%3A%3D.t%2Cuntyped%2Cuntyped"
    title="`:=`(lhs, rhs: untyped): untyped">`:=`</a></li>
  <li><a class="reference" href="#%3F%3D.t%2Cuntyped%2Cuntyped"
    title="`?=`(lhs, rhs: untyped): untyped">`?=`</a></li>

  </ul>
</li>

</ul>

  </div>
  
  <div class="nine columns" id="content">
  <div id="tocRoot"></div>
  
  <p class="module-desc"><blockquote><p>
"you can probably make a macro for that" -- Rika, 22-09-2020 10:41:51
</p></blockquote><table class="docinfo" frame="void" rules="none"><col class="docinfo-name" /><col class="docinfo-content" /><tbody valign="top"><tr><th class="docinfo-name">Author:</th><td> haxscramper</td></tr>
</tbody></table><p>This module implements pattern matching for objects, tuples, sequences, key-value pairs, case and derived objects. DSL can also be used to create object trees (AST).</p>

<h1><a class="toc-backref" id="use-example" href="#use-example">Use example</a></h1><pre class="listing"><span class="Keyword">case</span> <span class="Punctuation">[</span><span class="Punctuation">(</span><span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="DecNumber">3</span><span class="Punctuation">)</span><span class="Punctuation">,</span> <span class="Punctuation">(</span><span class="DecNumber">3</span><span class="Punctuation">,</span> <span class="DecNumber">4</span><span class="Punctuation">)</span><span class="Punctuation">]</span><span class="Punctuation">:</span>
  <span class="Keyword">of</span> <span class="Punctuation">[</span><span class="Punctuation">(</span><span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="Identifier">_</span><span class="Punctuation">)</span><span class="Punctuation">,</span> <span class="Identifier">_</span><span class="Punctuation">]</span><span class="Punctuation">:</span> <span class="DecNumber">1</span>
  <span class="Keyword">else</span><span class="Punctuation">:</span> <span class="DecNumber">999</span></pre>
<h1><a class="toc-backref" id="quick-reference" href="#quick-reference">Quick reference</a></h1><table border="1" class="docutils"><tr><th>Example</th><th>Explanation</th></tr>
<tr><td><tt class="docutils literal"><span class="pre">(fld: @val)</span></tt></td><td>Field <tt class="docutils literal"><span class="pre">fld</span></tt> into variable <tt class="docutils literal"><span class="pre">@val</span></tt></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">Kind()</span></tt></td><td>Object with <tt class="docutils literal"><span class="pre">.kind == Kind()</span></tt> [1]_</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">of Derived()</span></tt></td><td>Match object of derived type</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">(@val, _)</span></tt></td><td>First element in tuple in <tt class="docutils literal"><span class="pre">@val</span></tt></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">(@val, @val)</span></tt></td><td>Tuple with two equal elements</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">{&quot;key&quot; : @val}</span></tt></td><td>Table with &quot;key&quot;, capture into <tt class="docutils literal"><span class="pre">@val</span></tt> [2]_</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">[_, _]</span></tt></td><td>Sequence with <tt class="docutils literal"><span class="pre">len == 2</span></tt> [3]_</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">[_, .._]</span></tt></td><td>At least one element</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">[_, all @val]</span></tt></td><td>All elements starting from index <tt class="docutils literal"><span class="pre">1</span></tt></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">[until @val == &quot;2&quot;, .._]</span></tt></td><td>Capture all elements <em>until</em> first <tt class="docutils literal"><span class="pre">&quot;2&quot;</span></tt> [4]_</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">[until @val == 1, @val]</span></tt></td><td>All <em>including</em> first match</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">[all @val == 12]</span></tt></td><td>All elements are <tt class="docutils literal"><span class="pre">== 12</span></tt>, capture into <tt class="docutils literal"><span class="pre">@val</span></tt></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">[some @val == 12]</span></tt></td><td>At least <em>one</em> is <tt class="docutils literal"><span class="pre">== 12</span></tt>, capture all matching into <tt class="docutils literal"><span class="pre">@val</span></tt></td></tr>
</table><ul class="simple"><li>[1] Kind fields can use shorted enum names - both <tt class="docutils literal"><span class="pre">nnkStrLit</span></tt> and <tt class="docutils literal"><span class="pre">StrLit</span></tt> will work (prefix <tt class="docutils literal"><span class="pre">nnk</span></tt> can be omitted)</li>
<li>[2] Or any object with <tt class="docutils literal"><span class="pre">contains</span></tt> and <tt class="docutils literal"><span class="pre">[]</span></tt> defined (for necessary types)</li>
<li>[3] Or any object with <tt class="docutils literal"><span class="pre">len</span></tt> proc or field</li>
<li>[4] Note that sequence must mathc <em>fully</em> and it is necessary to have <tt class="docutils literal"><span class="pre">.._</span></tt> at the end in order to accept sequences of arbitrary length.</li>
</ul>

<h1><a class="toc-backref" id="supported-match-elements" href="#supported-match-elements">Supported match elements</a></h1><ul class="simple"><li><em>seqs</em> - matched using <tt class="docutils literal"><span class="pre">[Patt1(), Patt2(), ..]</span></tt>. Must have <tt class="docutils literal"><span class="pre">len(): int</span></tt> and <tt class="docutils literal"><span class="pre">[int]: T</span></tt> defined.</li>
<li><em>tuples</em> - matched using <tt class="docutils literal"><span class="pre">(Patt1(), Patt2(), ..)</span></tt>.</li>
<li><em>pairable</em> - matched using <tt class="docutils literal"><span class="pre">{Key: Patt()}</span></tt>. Must have <tt class="docutils literal"><span class="pre">[Key]: T</span></tt> defined. <tt class="docutils literal"><span class="pre">Key</span></tt> is not a pattern - search for whole collection won't be performed.</li>
<li><em>set</em> - matched using <tt class="docutils literal"><span class="pre">{Val1, Val2, .._}</span></tt>. Must have <tt class="docutils literal"><span class="pre">contains</span></tt> defined. If variable is captured then <tt class="docutils literal"><span class="pre">Val1</span></tt> must be comparable and collection should also implement <tt class="docutils literal"><span class="pre">items</span></tt> and <tt class="docutils literal"><span class="pre">incl</span></tt>.</li>
<li><em>object</em> - matched using <tt class="docutils literal"><span class="pre">(field: Val)</span></tt>. Case objects are matched using <tt class="docutils literal"><span class="pre">Kind(field: Val)</span></tt>. If you want to check agains multiple values for kind field <tt class="docutils literal"><span class="pre">(kind: in SomeSetOfKinds)</span></tt></li>
</ul>

<h1><a class="toc-backref" id="element-access" href="#element-access">Element access</a></h1><p>To determine whether or not particular object matches pattern <em>access path</em> is generated - sequence of fields and <tt class="docutils literal"><span class="pre">[]</span></tt> operators that you would normally write by hand, like <tt class="docutils literal"><span class="pre">fld.subfield[&quot;value&quot;].len</span></tt>. Due to support for <a class="reference external" href="https://nim-lang.org/docs/manual.html#procedures-method-call-syntax">method call syntax</a> there is no difference between field acccess and proc call, so things like <tt class="docutils literal"><span class="pre">(len: &lt; 12)</span></tt> also work as expected.</p>
<dl class="docutils"><dt><tt class="docutils literal"><span class="pre">(fld: &quot;3&quot;)</span></tt> Match field <tt class="docutils literal"><span class="pre">fld</span></tt> against <tt class="docutils literal"><span class="pre">&quot;3&quot;</span></tt>. Generated access</dt>
<dd>is <tt class="docutils literal"><span class="pre">expr.fld == &quot;3&quot;</span></tt>.</dd>
<dt><tt class="docutils literal"><span class="pre">[&quot;2&quot;]</span></tt> Match first element of expression agains patt. Generate</dt>
<dd>acess <tt class="docutils literal"><span class="pre">expr[pos] == &quot;2&quot;</span></tt>, where <tt class="docutils literal"><span class="pre">pos</span></tt> is an integer index for current position in sequence.</dd>
</dl>
<p><tt class="docutils literal"><span class="pre">(&quot;2&quot;)</span></tt> For each field generate access using <tt class="docutils literal"><span class="pre">[1]</span></tt></p>
<dl class="docutils"><dt><tt class="docutils literal"><span class="pre">{&quot;key&quot;: &quot;val&quot;}</span></tt> First check <tt class="docutils literal"><span class="pre">&quot;key&quot; in expr</span></tt> and then</dt>
<dd><tt class="docutils literal"><span class="pre">expr[&quot;key&quot;] == &quot;val&quot;</span></tt>. No exception on missing keys, just fail match.</dd>
</dl>
<p>It is possible to have mixed assess for objects. Mixed object access via <tt class="docutils literal"><span class="pre">(gg: _, [], {})</span></tt> creates the same code for checking. E.g <tt class="docutils literal"><span class="pre">([_])</span></tt> is the same as <tt class="docutils literal"><span class="pre">[_]</span></tt>, <tt class="docutils literal"><span class="pre">({&quot;key&quot;: &quot;val&quot;})</span></tt> is is identical to just <tt class="docutils literal"><span class="pre">{&quot;key&quot;: &quot;val&quot;}</span></tt>. You can also call functions and check their values (like <tt class="docutils literal"><span class="pre">(len: _(it &lt; 10))</span></tt> or <tt class="docutils literal"><span class="pre">(len: in {0 .. 10})</span></tt>) to check for sequence length.</p>

<h1><a class="toc-backref" id="checks" href="#checks">Checks</a></h1><ul class="simple"><li>Any operators with exception of <tt class="docutils literal"><span class="pre">is</span></tt> (subpattern) and <tt class="docutils literal"><span class="pre">of</span></tt> (derived object subpattern) is considered final comparison and just pasted as-is into generated pattern match code. E.g. <tt class="docutils literal"><span class="pre">fld: in {2,3,4}</span></tt> will generate <tt class="docutils literal"><span class="pre">expr.fld in {2,3,4}</span></tt></li>
<li><tt class="docutils literal"><span class="pre">(fld: is Patt())</span></tt> - check if <tt class="docutils literal"><span class="pre">expr.fld</span></tt> matches pattern <tt class="docutils literal"><span class="pre">Patt()</span></tt></li>
<li><tt class="docutils literal"><span class="pre">(fld: _.matchesPredicate())</span></tt> - if call to <tt class="docutils literal"><span class="pre">matchesPredicate(expr.fld)</span></tt> evaluates to true.</li>
</ul>
<p>Notation: <tt class="docutils literal"><span class="pre">&lt;expr&gt;</span></tt> refers to any possible combination of checks. For example</p>
<ul class="simple"><li><tt class="docutils literal"><span class="pre">fld: in {1,2,3}</span></tt> - <tt class="docutils literal"><span class="pre">&lt;expr&gt;</span></tt> is <tt class="docutils literal"><span class="pre">in {1,2,3}</span></tt></li>
<li><tt class="docutils literal"><span class="pre">[_]</span></tt> - <tt class="docutils literal"><span class="pre">&lt;expr&gt;</span></tt> is <tt class="docutils literal"><span class="pre">_</span></tt></li>
<li><tt class="docutils literal"><span class="pre">fld: is Patt()</span></tt> - <tt class="docutils literal"><span class="pre">&lt;expr&gt;</span></tt> is <tt class="docutils literal"><span class="pre">is Patt()</span></tt></li>
</ul>

<h2><a class="toc-backref" id="checks-examples" href="#checks-examples">Examples</a></h2><ul class="simple"><li><tt class="docutils literal"><span class="pre">(fld: 12)</span></tt> If rhs for key-value pair is integer, string or identifier then <tt class="docutils literal"><span class="pre">==</span></tt> comparison will be generated.</li>
<li><tt class="docutils literal"><span class="pre">(fld: == ident(&quot;33&quot;))</span></tt> if rhs is a prefix of <tt class="docutils literal"><span class="pre">==</span></tt> then <tt class="docutils literal"><span class="pre">==</span></tt> will be generated. Any for of prefix operator will be converted to <tt class="docutils literal"><span class="pre">expr.fld &lt;op&gt; &lt;rhs&gt;</span></tt>.</li>
<li><tt class="docutils literal"><span class="pre">(fld: in {1, 3, 3})</span></tt> or <tt class="docutils literal"><span class="pre">(fld: in Anything)</span></tt> creates <tt class="docutils literal"><span class="pre">fld.expr in Anything</span></tt>. Either <tt class="docutils literal"><span class="pre">in</span></tt> or <tt class="docutils literal"><span class="pre">notin</span></tt> can be used.</li>
</ul>

<h1><a class="toc-backref" id="variable-binding" href="#variable-binding">Variable binding</a></h1><p>Match can be bound to new varaible. All variable declarations happen via <tt class="docutils literal"><span class="pre">@varname</span></tt> syntax.</p>
<ul class="simple"><li>To bind element to variable without any additional checks do: <tt class="docutils literal"><span class="pre">(fld: @varname)</span></tt></li>
<li>To bind element with some additional operator checks do:<ul class="simple"><li><tt class="docutils literal"><span class="pre">(fld: @varname &lt;operator&gt; Value)</span></tt> first perform check using <tt class="docutils literal"><span class="pre">&lt;operator&gt;</span></tt> and then add <tt class="docutils literal"><span class="pre">Value</span></tt> to <tt class="docutils literal"><span class="pre">@varname</span></tt><ul class="simple"><li><tt class="docutils literal"><span class="pre">(fld: @hello is (&quot;2&quot; | &quot;3&quot;))</span></tt></li>
</ul>
</li>
</ul>
</li>
<li>Predicate checks: <tt class="docutils literal"><span class="pre">fld: @a.matchPredicate()</span></tt></li>
<li>Arbitrary expression: <tt class="docutils literal"><span class="pre">fld: @a(it mod 2 == 0)</span></tt>. If expression has no type it is considered <tt class="docutils literal"><span class="pre">true</span></tt>.</li>
</ul>

<h2><a class="toc-backref" id="variable-binding-bind-order" href="#variable-binding-bind-order">Bind order</a></h2><p>Bind order: if check evaluates to true variable is bound immediately, making it possible to use in other checks. <tt class="docutils literal"><span class="pre">[@head, any @tail != head]</span></tt> is a valid pattern. First match <tt class="docutils literal"><span class="pre">head</span></tt> and then any number of <tt class="docutils literal"><span class="pre">@tail</span></tt> elements. Can use <tt class="docutils literal"><span class="pre">any _(if it != head: tail.add it)</span></tt> and declare <tt class="docutils literal"><span class="pre">tail</span></tt> externally.</p>
<p>Variable is never rebound. After it is bound, then it will have the value of first binding.</p>

<h2><a class="toc-backref" id="variable-binding-bind-variable-type" href="#variable-binding-bind-variable-type">Bind variable type</a></h2><ul class="simple"><li>Any variadics are mapped to sequence</li>
<li>Only once in alternative is option</li>
<li>Explicitly optional is option</li>
<li>Optional with default value is regular value</li>
<li>Variable can be used only once if in alternative</li>
</ul>
<table border="1" class="docutils"><tr><th>Pattern</th><th>Ijected variables</th></tr>
<tr><td><tt class="docutils literal"><span class="pre">[@a]</span></tt></td><td><tt class="docutils literal"><span class="pre">var a: typeof(expr[0])</span></tt></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">{&quot;key&quot;: @val}</span></tt></td><td><tt class="docutils literal"><span class="pre">var val: typeof(expr[&quot;key&quot;])</span></tt></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">[all @a]</span></tt></td><td><tt class="docutils literal"><span class="pre">var a: seq[typeof(expr[0])]</span></tt></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">[opt @val]</span></tt></td><td><tt class="docutils literal"><span class="pre">var a: Option[typeof(expr[0])]</span></tt></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">[opt @val or default]</span></tt></td><td><tt class="docutils literal"><span class="pre">var a: typeof(expr[0])</span></tt></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">(fld: @val)</span></tt></td><td><tt class="docutils literal"><span class="pre">var val: typeof(expr.fld)</span></tt></td></tr>
</table>
<h1><a class="toc-backref" id="matching-different-things" href="#matching-different-things">Matching different things</a></h1>
<h2><a class="toc-backref" id="matching-different-things-sequence-matching" href="#matching-different-things-sequence-matching">Sequence matching</a></h2><p>Input sequence: <tt class="docutils literal"><span class="pre">[1,2,3,4,5,6,5,6]</span></tt></p>
<table border="1" class="docutils"><tr><th>Pattern</th><th>Result</th><th>Comment</th></tr>
<tr><td><tt class="docutils literal"><span class="pre">[_]</span></tt></td><td><strong>Fail</strong></td><td>Input sequence size mismatch</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">[.._]</span></tt></td><td><strong>Ok</strong></td><td></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">[@a]</span></tt></td><td><strong>Fail</strong></td><td>Input sequence size mismatch</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">[@a, .._]</span></tt></td><td><strong>Ok</strong>, <tt class="docutils literal"><span class="pre">a = 1</span></tt></td><td></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">[any @a, .._]</span></tt></td><td><strong>Error</strong></td><td></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">[any @a(it &lt; 10)]</span></tt></td><td><strong>Ok</strong>, <tt class="docutils literal"><span class="pre">a = [1..6]</span></tt></td><td>Capture all elements that match</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">[until @a == 6, .._]</span></tt></td><td><strong>Ok</strong></td><td>All until first ocurrence of <tt class="docutils literal"><span class="pre">6</span></tt></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">[all @a == 6, .._]</span></tt></td><td><strong>Ok</strong> <tt class="docutils literal"><span class="pre">a = []</span></tt></td><td>All leading <tt class="docutils literal"><span class="pre">6</span></tt></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">[any @a(it &gt; 100)]</span></tt></td><td><strong>Fail</strong></td><td>No elements <tt class="docutils literal"><span class="pre">&gt; 100</span></tt></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">[none @a(it in {6 .. 10})]</span></tt></td><td><strong>Fail</strong></td><td>There is an element <tt class="docutils literal"><span class="pre">== 6</span></tt></td></tr>
</table><dl class="docutils"><dt><tt class="docutils literal"><span class="pre">until</span></tt></dt>
<dd>non-greedy. Match everything until <tt class="docutils literal"><span class="pre">&lt;expr&gt;</span></tt><ul class="simple"><li><tt class="docutils literal"><span class="pre">until &lt;expr&gt;</span></tt>: match all until frist element that matches Expr</li>
</ul>
</dd>
<dt><tt class="docutils literal"><span class="pre">all</span></tt></dt>
<dd>greedy. Match everything that matches <tt class="docutils literal"><span class="pre">&lt;expr&gt;</span></tt><ul class="simple"><li><tt class="docutils literal"><span class="pre">all &lt;expr&gt;</span></tt>: all elements should match Expr</li>
<li><tt class="docutils literal"><span class="pre">all @val is &lt;expr&gt;</span></tt>: capture all elements in <tt class="docutils literal"><span class="pre">@val</span></tt> if <tt class="docutils literal"><span class="pre">&lt;expr&gt;</span></tt> is true for every one of them.</li>
</ul>
</dd>
<dt><tt class="docutils literal"><span class="pre">opt</span></tt></dt>
<dd>Single element match<ul class="simple"><li><tt class="docutils literal"><span class="pre">opt @a</span></tt>: match optional element and bind it to a</li>
<li><tt class="docutils literal"><span class="pre">opt @a or &quot;default&quot;</span></tt>: either match element to a or set a to &quot;default&quot;</li>
</ul>
</dd>
<dt><tt class="docutils literal"><span class="pre">any</span></tt></dt>
<dd>greedy. Consume all sequence elements until the end and succed only if any element has matched.<ul class="simple"><li><tt class="docutils literal"><span class="pre">any @val is &quot;d&quot;</span></tt>: capture all element that match <tt class="docutils literal"><span class="pre">is &quot;d&quot;</span></tt></li>
</ul>
</dd>
<dt><tt class="docutils literal"><span class="pre">none</span></tt></dt>
<dd>greedy. Consume all sequence elements until the end and succed only if any element has matched. EE</dd>
<dt><tt class="docutils literal"><span class="pre">[m .. n @capture]</span></tt></dt>
<dd>Capture slice of elements from index <tt class="docutils literal"><span class="pre">m</span></tt> to <tt class="docutils literal"><span class="pre">n</span></tt></dd>
</dl>
<p>Greedy patterns match until the end of a sequence and cannot be followed by anything else.</p>
<p>For sequence to match is must either be completely matched by all subpatterns or have trailing <tt class="docutils literal"><span class="pre">.._</span></tt> in pattern.</p>
<table border="1" class="docutils"><tr><th>Sequence</th><th>Pattern</th><th>Match result</th></tr>
<tr><td><tt class="docutils literal"><span class="pre">[1,2,3]</span></tt></td><td><tt class="docutils literal"><span class="pre">[1,2]</span></tt> <tt class="docutils literal"><span class="pre">[1, .._]</span></tt> <tt class="docutils literal"><span class="pre">[1,2,_]</span></tt></td><td><strong>Fail</strong> <strong>Ok</strong> <strong>Ok</strong></td></tr>
</table><p>More use examples</p>
<ul class="simple"><li>capture all elements in sequence: <tt class="docutils literal"><span class="pre">[all @elems]</span></tt></li>
<li>get all elements until (not including &quot;d&quot;): <tt class="docutils literal"><span class="pre">[until @a is &quot;d&quot;]</span></tt></li>
<li>All leading &quot;d&quot;: <tt class="docutils literal"><span class="pre">[all @leading is &quot;d&quot;]</span></tt></li>
<li>Match first two elements and ignore the rest <tt class="docutils literal"><span class="pre">[_, _, .._]</span></tt></li>
<li>Match optional third element <tt class="docutils literal"><span class="pre">[_, _, opt @trail]</span></tt></li>
<li>Match third element and if not matched use default value <tt class="docutils literal"><span class="pre">[_, _, opt @trail or &quot;default&quot;]</span></tt></li>
<li>Capture all elements until first separator: <tt class="docutils literal"><span class="pre">[until @leading is &quot;sep&quot;, @middle is &quot;sep&quot;, all @trailing]</span></tt></li>
<li>Extract all conditions from IfStmt: <tt class="docutils literal"><span class="pre">IfStmt([all ElseIf([@cond, _]), .._])</span></tt></li>
</ul>
<p>How different sequence matching keywords map to regular for-loops?</p>
<pre class="listing"><span class="Comment"># all</span>
<span class="Keyword">var</span> <span class="Identifier">allOk</span> <span class="Operator">=</span> <span class="Identifier">false</span>
<span class="Keyword">while</span> <span class="Identifier">position</span> <span class="Operator">&lt;</span> <span class="Identifier">len</span><span class="Punctuation">:</span>
  <span class="Keyword">if</span> <span class="Identifier">matchExpr</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">inc</span> <span class="Identifier">position</span>
  <span class="Keyword">else</span><span class="Punctuation">:</span> <span class="Identifier">allOk</span> <span class="Operator">=</span> <span class="Identifier">false</span><span class="Punctuation">;</span> <span class="Keyword">break</span>

<span class="Keyword">if</span> <span class="Keyword">not</span> <span class="Identifier">allOk</span><span class="Punctuation">:</span> <span class="Comment"># Fail match</span></pre><pre class="listing"><span class="Comment"># any</span>
<span class="Keyword">var</span> <span class="Identifier">foundOk</span> <span class="Operator">=</span> <span class="Identifier">false</span>
<span class="Keyword">while</span> <span class="Identifier">position</span> <span class="Operator">&lt;</span> <span class="Identifier">len</span><span class="Punctuation">:</span>
  <span class="Keyword">if</span> <span class="Identifier">matchExpr</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">foundOk</span> <span class="Operator">=</span> <span class="Identifier">true</span>
  <span class="Identifier">inc</span> <span class="Identifier">position</span>

<span class="Keyword">if</span> <span class="Keyword">not</span> <span class="Identifier">foundOk</span><span class="Punctuation">:</span> <span class="Comment"># Fail match</span></pre><pre class="listing"><span class="Comment"># until</span>
<span class="Keyword">var</span> <span class="Identifier">foundOk</span> <span class="Operator">=</span> <span class="Identifier">false</span>
<span class="Keyword">while</span> <span class="Identifier">position</span> <span class="Operator">&lt;</span> <span class="Identifier">len</span><span class="Punctuation">:</span>
  <span class="Keyword">if</span> <span class="Keyword">not</span> <span class="Identifier">matchExpr</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Keyword">break</span>
  <span class="Keyword">else</span><span class="Punctuation">:</span> <span class="Identifier">inc</span> <span class="Identifier">position</span>

<span class="Comment"># Continue with next matches</span></pre>
<h2><a class="toc-backref" id="matching-different-things-tuple-matching" href="#matching-different-things-tuple-matching">Tuple matching</a></h2><p>Input tuple: <tt class="docutils literal"><span class="pre">(1, 2, &quot;fa&quot;)</span></tt></p>
<table border="1" class="docutils"><tr><th>Pattern</th><th>Result</th><th>Comment</th></tr>
<tr><td><tt class="docutils literal"><span class="pre">(_, _, _)</span></tt></td><td><strong>Ok</strong></td><td>Match all</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">(@a, @a, _)</span></tt></td><td><strong>Fail</strong></td><td></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">(@a is (1 | 2), @a, _)</span></tt></td><td><strong>Error</strong></td><td></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">(1, 1 | 2, _)</span></tt></td><td><strong>Ok</strong></td><td></td></tr>
</table>
<h2><a class="toc-backref" id="matching-different-things-case-object-matching" href="#matching-different-things-case-object-matching">Case object matching</a></h2><p>Input AST</p>
<pre class="listing"><span class="Identifier">ForStmt</span>
  <span class="Identifier">Ident</span> <span class="StringLit">&quot;i&quot;</span>
  <span class="Identifier">Infix</span>
    <span class="Identifier">Ident</span> <span class="StringLit">&quot;..&quot;</span>
    <span class="Identifier">IntLit</span> <span class="DecNumber">1</span>
    <span class="Identifier">IntLit</span> <span class="DecNumber">10</span>
  <span class="Identifier">StmtList</span>
    <span class="Identifier">Command</span>
      <span class="Identifier">Ident</span> <span class="StringLit">&quot;echo&quot;</span>
      <span class="Identifier">IntLit</span> <span class="DecNumber">12</span></pre><ul class="simple"><li><tt class="docutils literal"><span class="pre">ForStmt([== ident(&quot;i&quot;), .._])</span></tt> Only for loops with <tt class="docutils literal"><span class="pre">i</span></tt> as variable</li>
<li><tt class="docutils literal"><span class="pre">ForStmt([@a is Ident(), .._])</span></tt> Capture for loop variable</li>
<li><tt class="docutils literal"><span class="pre">ForStmt([@a.isTuple(), .._])</span></tt> for loops in which first subnode satisfies predicate <tt class="docutils literal"><span class="pre">isTuple()</span></tt>. Bind match to <tt class="docutils literal"><span class="pre">a</span></tt></li>
<li><tt class="docutils literal"><span class="pre">ForStmt([_, _, (len: in {1 .. 10})])</span></tt> between one to ten statements in the for loop body</li>
</ul>

<h2><a class="toc-backref" id="matching-different-things-ref-object-matching" href="#matching-different-things-ref-object-matching">Ref object matching</a></h2><p>Matching for ref objects is not really different from regular one - the only difference is that you need to use <tt class="docutils literal"><span class="pre">of</span></tt> operator explicitly. For example, if you want to do <tt class="docutils literal"><span class="pre">case</span></tt> match for different object kinds - and</p>
<pre class="listing"><span class="Keyword">case</span> <span class="Identifier">Obj</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="Keyword">of</span> <span class="Keyword">of</span> <span class="Identifier">StmtList</span><span class="Punctuation">(</span><span class="Identifier">subfield</span><span class="Punctuation">:</span> <span class="Operator">@</span><span class="Identifier">capture</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
    <span class="Comment"># do something with `capture`</span></pre><p>You can use <tt class="docutils literal"><span class="pre">of</span></tt> as prefix operator - things like <tt class="docutils literal"><span class="pre">{12 : of SubRoot(fld1: @fld1)}</span></tt>, or  <tt class="docutils literal"><span class="pre">[any of Derived()]</span></tt>.</p>

<h2><a class="toc-backref" id="matching-different-things-kvminuspairs-matching" href="#matching-different-things-kvminuspairs-matching">KV-pairs matching</a></h2><p>Input json string</p>
<pre class="listing">
{&quot;menu&quot;: {
  &quot;id&quot;: &quot;file&quot;,
  &quot;value&quot;: &quot;File&quot;,
  &quot;popup&quot;: {
    &quot;menuitem&quot;: [
      {&quot;value&quot;: &quot;New&quot;, &quot;onclick&quot;: &quot;CreateNewDoc()&quot;},
      {&quot;value&quot;: &quot;Open&quot;, &quot;onclick&quot;: &quot;OpenDoc()&quot;},
      {&quot;value&quot;: &quot;Close&quot;, &quot;onclick&quot;: &quot;CloseDoc()&quot;}
    ]
  }
}}</pre><ul class="simple"><li>Get input <tt class="docutils literal"><span class="pre">[&quot;menu&quot;][&quot;file&quot;]</span></tt> from node and</li>
</ul>
<pre class="listing"><span class="Keyword">case</span> <span class="Identifier">inj</span><span class="Punctuation">:</span>
  <span class="Keyword">of</span> <span class="Punctuation">{</span><span class="StringLit">&quot;menu&quot;</span> <span class="Punctuation">:</span> <span class="Punctuation">{</span><span class="StringLit">&quot;file&quot;</span><span class="Punctuation">:</span> <span class="Operator">@</span><span class="Identifier">file</span> <span class="Keyword">is</span> <span class="Identifier">JString</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">}</span><span class="Punctuation">}</span><span class="Punctuation">:</span>
    <span class="Comment"># ...</span>
  <span class="Keyword">else</span><span class="Punctuation">:</span>
    <span class="Identifier">raiseAssert</span><span class="Punctuation">(</span><span class="StringLit">&quot;Expected [menu][file] as string, but found &quot;</span> <span class="Operator">&amp;</span> <span class="Operator">$</span><span class="Identifier">inj</span><span class="Punctuation">)</span></pre>
<h2><a class="toc-backref" id="matching-different-things-option-matching" href="#matching-different-things-option-matching">Option matching</a></h2><p><tt class="docutils literal"><span class="pre">Some(@x)</span></tt> and <tt class="docutils literal"><span class="pre">None()</span></tt> is a special case that will be rewritten into <tt class="docutils literal"><span class="pre">(isSome: true, get: @x)</span></tt> and <tt class="docutils literal"><span class="pre">(isNone: true)</span></tt> respectively. This is made to allow better integration with optional types.  [9]_ .</p>

<h1><a class="toc-backref" id="tree-construction" href="#tree-construction">Tree construction</a></h1><p><tt class="docutils literal"><span class="pre">makeTree</span></tt> provides 'reversed' implementation of pattern matching, which allows to <em>construct</em> tree from pattern, using variables. Example of use</p>
<pre class="listing"><span class="Keyword">type</span>
  <span class="Identifier">HtmlNodeKind</span> <span class="Operator">=</span> <span class="Keyword">enum</span>
    <span class="Identifier">htmlBase</span> <span class="Operator">=</span> <span class="StringLit">&quot;base&quot;</span>
    <span class="Identifier">htmlHead</span> <span class="Operator">=</span> <span class="StringLit">&quot;head&quot;</span>
    <span class="Identifier">htmlLink</span> <span class="Operator">=</span> <span class="StringLit">&quot;link&quot;</span>
  
  <span class="Identifier">HtmlNode</span> <span class="Operator">=</span> <span class="Keyword">object</span>
    <span class="Identifier">kind</span><span class="Operator">*:</span> <span class="Identifier">HtmlNodeKind</span>
    <span class="Identifier">text</span><span class="Operator">*:</span> <span class="Identifier">string</span>
    <span class="Identifier">subn</span><span class="Operator">*:</span> <span class="Identifier">seq</span><span class="Punctuation">[</span><span class="Identifier">HtmlNode</span><span class="Punctuation">]</span>

<span class="Keyword">func</span> <span class="Identifier">add</span><span class="Punctuation">(</span><span class="Identifier">n</span><span class="Punctuation">:</span> <span class="Keyword">var</span> <span class="Identifier">HtmlNode</span><span class="Punctuation">,</span> <span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">HtmlNode</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Identifier">n</span><span class="Operator">.</span><span class="Identifier">subn</span><span class="Operator">.</span><span class="Identifier">add</span> <span class="Identifier">s</span>

<span class="Keyword">discard</span> <span class="Identifier">makeTree</span><span class="Punctuation">(</span><span class="Identifier">HtmlNode</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="Identifier">base</span><span class="Punctuation">:</span>
    <span class="Identifier">link</span><span class="Punctuation">(</span><span class="Identifier">text</span><span class="Punctuation">:</span> <span class="StringLit">&quot;hello&quot;</span><span class="Punctuation">)</span></pre><p>In order to construct tree, <tt class="docutils literal"><span class="pre">kind=</span></tt> and <tt class="docutils literal"><span class="pre">add</span></tt> have to be defined. Internally DSL just creats resulting object, sets <tt class="docutils literal"><span class="pre">kind=</span></tt> and then repeatedly <tt class="docutils literal"><span class="pre">add</span></tt> elements to it. In order to properties for objects either the field has to be exported, or <tt class="docutils literal"><span class="pre">fld=</span></tt> has to be defined (where <tt class="docutils literal"><span class="pre">fld</span></tt> is the name of property you want to set).</p>
</p>
  <div class="section" id="7">
<h1><a class="toc-backref" href="#7">Types</a></h1>
<dl class="item">
<a id="FieldIndex"></a>
<dt><pre><a href="matching.html#FieldIndex"><span class="Identifier">FieldIndex</span></a> <span class="Other">=</span> <span class="Keyword">distinct</span> <span class="Identifier">int</span></pre></dt>
<dd>



</dd>
<a id="MatchKind"></a>
<dt><pre><a href="matching.html#MatchKind"><span class="Identifier">MatchKind</span></a> <span class="Other">=</span> <span class="Keyword">enum</span>
  <span class="Identifier">kItem</span><span class="Other">,</span>                    <span class="Comment">## Match single element</span>
  <span class="Identifier">kSeq</span><span class="Other">,</span>                     <span class="Comment">## Match sequence of elements</span>
  <span class="Identifier">kTuple</span><span class="Other">,</span>                   <span class="Comment">## Mach tuple (anonymous or named)</span>
  <span class="Identifier">kPairs</span><span class="Other">,</span>                   <span class="Comment">## Match key-value pairs</span>
  <span class="Identifier">kObject</span><span class="Other">,</span>                  <span class="Comment">## Match object, named tuple or object-like value</span>
  <span class="Identifier">kSet</span><span class="Other">,</span>                     <span class="Comment">## Match set of elements</span>
  <span class="Identifier">kAlt</span>                       <span class="Comment">## Ordered choice - mactch any of patterns.</span></pre></dt>
<dd>

Different kinds of matching patterns

</dd>
<a id="SeqKeyword"></a>
<dt><pre><a href="matching.html#SeqKeyword"><span class="Identifier">SeqKeyword</span></a> <span class="Other">=</span> <span class="Keyword">enum</span>
  <span class="Identifier">lkAny</span> <span class="Other">=</span> <span class="StringLit">&quot;any&quot;</span><span class="Other">,</span>            <span class="Comment">## Any element from seq</span>
  <span class="Identifier">lkAll</span> <span class="Other">=</span> <span class="StringLit">&quot;all&quot;</span><span class="Other">,</span>            <span class="Comment">## All elements from seq</span>
  <span class="Identifier">lkNone</span> <span class="Other">=</span> <span class="StringLit">&quot;none&quot;</span><span class="Other">,</span>          <span class="Comment">## None of the elements from seq</span>
  <span class="Identifier">lkOpt</span> <span class="Other">=</span> <span class="StringLit">&quot;opt&quot;</span><span class="Other">,</span>            <span class="Comment">## Optionaly match element in seq</span>
  <span class="Identifier">lkUntil</span> <span class="Other">=</span> <span class="StringLit">&quot;until&quot;</span><span class="Other">,</span>        <span class="Comment">## All elements until</span>
  <span class="Identifier">lkPref</span> <span class="Other">=</span> <span class="StringLit">&quot;pref&quot;</span><span class="Other">,</span>          <span class="Comment">## All elements while</span>
  <span class="Identifier">lkPos</span><span class="Other">,</span>                    <span class="Comment">## Exact position</span>
  <span class="Identifier">lkSlice</span><span class="Other">,</span>                  <span class="Comment">## Subrange slice</span>
  <span class="Identifier">lkTrail</span>                    <span class="Comment">## Variadic placeholder `.._`</span></pre></dt>
<dd>

Possible special words for seq pattern matching

</dd>
<a id="SeqStructure"></a>
<dt><pre><a href="matching.html#SeqStructure"><span class="Identifier">SeqStructure</span></a> <span class="Other">=</span> <span class="Keyword">object</span>
  <span class="Identifier">decl</span><span class="Other">:</span> <span class="Identifier">NimNode</span>              <span class="Comment">## Original declaration of the node</span>
  <span class="Identifier">bindVar</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">Option</span><span class="Other">[</span><span class="Identifier">NimNode</span><span class="Other">]</span>  <span class="Comment">## Optional bound variable</span>
  <span class="Identifier">patt</span><span class="Operator">*</span><span class="Other">:</span> <a href="matching.html#Match"><span class="Identifier">Match</span></a>               <span class="Comment">## Patterh for element matching</span>
  <span class="Keyword">case</span> <span class="Identifier">kind</span><span class="Operator">*</span><span class="Other">:</span> <a href="matching.html#SeqKeyword"><span class="Identifier">SeqKeyword</span></a>
  <span class="Keyword">of</span> <span class="Identifier">lkSlice</span><span class="Other">:</span>
      <span class="Identifier">slice</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">NimNode</span>

  <span class="Keyword">else</span><span class="Other">:</span>
      <span class="Keyword">nil</span>

  </pre></dt>
<dd>



</dd>
<a id="ItemMatchKind"></a>
<dt><pre><a href="matching.html#ItemMatchKind"><span class="Identifier">ItemMatchKind</span></a> <span class="Other">=</span> <span class="Keyword">enum</span>
  <span class="Identifier">imkInfixEq</span><span class="Other">,</span>               <span class="Comment">## Match item using infix operator</span>
  <span class="Identifier">imkSubpatt</span><span class="Other">,</span>               <span class="Comment">## Match item by checking it agains subpattern</span>
  <span class="Identifier">imkPredicate</span>               <span class="Comment">## Execute custom predicate to determine if element</span>
                             <span class="Comment">## matches pattern.</span></pre></dt>
<dd>

Type of item pattern match

</dd>
<a id="KVPair"></a>
<dt><pre><a href="matching.html#KVPair"><span class="Identifier">KVPair</span></a> <span class="Other">=</span> <span class="Keyword">object</span>
  <span class="Identifier">key</span><span class="Other">:</span> <span class="Identifier">NimNode</span>
  <span class="Identifier">patt</span><span class="Other">:</span> <a href="matching.html#Match"><span class="Identifier">Match</span></a>
</pre></dt>
<dd>



</dd>
<a id="MatchError"></a>
<dt><pre><a href="matching.html#MatchError"><span class="Identifier">MatchError</span></a> <span class="Other">=</span> <span class="Keyword">ref</span> <span class="Keyword">object</span> <span class="Keyword">of</span> <span class="Identifier">CatchableError</span></pre></dt>
<dd>

Exception indicating match failure

</dd>
<a id="Match"></a>
<dt><pre><a href="matching.html#Match"><span class="Identifier">Match</span></a> <span class="Other">=</span> <span class="Keyword">ref</span> <span class="Keyword">object</span>
  <span class="Identifier">bindVar</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">Option</span><span class="Other">[</span><span class="Identifier">NimNode</span><span class="Other">]</span>  <span class="Comment">## Bound variable (if any)</span>
  <span class="Identifier">declNode</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">NimNode</span>         <span class="Comment">## Original declaration of match</span>
  <span class="Identifier">isOptional</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">bool</span>
  <span class="Identifier">fallback</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">Option</span><span class="Other">[</span><span class="Identifier">NimNode</span><span class="Other">]</span> <span class="Comment">## Default value in case match fails</span>
  <span class="Keyword">case</span> <span class="Identifier">kind</span><span class="Operator">*</span><span class="Other">:</span> <a href="matching.html#MatchKind"><span class="Identifier">MatchKind</span></a>
  <span class="Keyword">of</span> <span class="Identifier">kItem</span><span class="Other">:</span>
      <span class="Keyword">case</span> <span class="Identifier">itemMatch</span><span class="Other">:</span> <a href="matching.html#ItemMatchKind"><span class="Identifier">ItemMatchKind</span></a>
      <span class="Keyword">of</span> <span class="Identifier">imkInfixEq</span><span class="Other">:</span>
          <span class="Identifier">infix</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">string</span>     <span class="Comment">## Infix operator used for comparison</span>
          <span class="Identifier">rhsNode</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">NimNode</span>  <span class="Comment">## Rhs expression to compare against</span>
          <span class="Identifier">isPlaceholder</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">bool</span> <span class="Comment">## Always true? `_` pattern is an</span>
                               <span class="Comment">## infix expression with `isPlaceholder` equal to true</span>
        
      <span class="Keyword">of</span> <span class="Identifier">imkSubpatt</span><span class="Other">:</span>
          <span class="Identifier">rhsPatt</span><span class="Operator">*</span><span class="Other">:</span> <a href="matching.html#Match"><span class="Identifier">Match</span></a>    <span class="Comment">## Subpattern to compare value against</span>
        
      <span class="Keyword">of</span> <span class="Identifier">imkPredicate</span><span class="Other">:</span>
          <span class="Identifier">isCall</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">bool</span>      <span class="Comment">## Predicate is a call expression</span>
                             <span class="Comment">## (`@val.matches()`) or a free-standing expression</span>
                             <span class="Comment">## (`@val(it.len &lt; 100)`)</span>
          <span class="Identifier">predBody</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">NimNode</span> <span class="Comment">## Body of the expression</span>
        
    
  <span class="Keyword">of</span> <span class="Identifier">kAlt</span><span class="Other">:</span>
      <span class="Identifier">altElems</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">seq</span><span class="Other">[</span><a href="matching.html#Match"><span class="Identifier">Match</span></a><span class="Other">]</span>  <span class="Comment">## Alternatives for matching</span>
    
  <span class="Keyword">of</span> <span class="Identifier">kSeq</span><span class="Other">:</span>
      <span class="Identifier">seqElems</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">seq</span><span class="Other">[</span><a href="matching.html#SeqStructure"><span class="Identifier">SeqStructure</span></a><span class="Other">]</span> <span class="Comment">## Sequence subpatterns</span>
    
  <span class="Keyword">of</span> <span class="Identifier">kTuple</span><span class="Other">:</span>
      <span class="Identifier">tupleElems</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">seq</span><span class="Other">[</span><a href="matching.html#Match"><span class="Identifier">Match</span></a><span class="Other">]</span> <span class="Comment">## Tuple elements</span>
    
  <span class="Keyword">of</span> <span class="Identifier">kPairs</span><span class="Other">:</span>
      <span class="Identifier">pairElems</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">seq</span><span class="Other">[</span><a href="matching.html#KVPair"><span class="Identifier">KVPair</span></a><span class="Other">]</span>
      <span class="Identifier">nocheck</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">bool</span>

  <span class="Keyword">of</span> <span class="Identifier">kSet</span><span class="Other">:</span>
      <span class="Identifier">setElems</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">seq</span><span class="Other">[</span><a href="matching.html#Match"><span class="Identifier">Match</span></a><span class="Other">]</span>

  <span class="Keyword">of</span> <span class="Identifier">kObject</span><span class="Other">:</span>
      <span class="Identifier">kindCall</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">Option</span><span class="Other">[</span><span class="Identifier">NimNode</span><span class="Other">]</span> <span class="Comment">## Optional node with kind</span>
                                 <span class="Comment">## expression pattern (see `hasKind`)</span>
      <span class="Identifier">isRefKind</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">bool</span>
      <span class="Identifier">fldElems</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">seq</span><span class="Other">[</span><span class="Keyword">tuple</span><span class="Other">[</span><span class="Identifier">name</span><span class="Other">:</span> <span class="Identifier">string</span><span class="Other">,</span> <span class="Identifier">patt</span><span class="Other">:</span> <a href="matching.html#Match"><span class="Identifier">Match</span></a><span class="Other">]</span><span class="Other">]</span>
      <span class="Identifier">kvMatches</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">Option</span><span class="Other">[</span><a href="matching.html#Match"><span class="Identifier">Match</span></a><span class="Other">]</span> <span class="Comment">## Optional key-value matches for</span>
                                <span class="Comment">## expressions like `JObject({&quot;key&quot;: @val})`</span>
      <span class="Identifier">seqMatches</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">Option</span><span class="Other">[</span><a href="matching.html#Match"><span class="Identifier">Match</span></a><span class="Other">]</span> <span class="Comment">## Optional indexed matches for</span>
                                 <span class="Comment">## subelement access using `Infix([@op, @lhs, @rhs])` pattern.</span>
    
  </pre></dt>
<dd>

Object describing single match for element

</dd>
<a id="VarKind"></a>
<dt><pre><a href="matching.html#VarKind"><span class="Identifier">VarKind</span></a> <span class="Other">=</span> <span class="Keyword">enum</span>
  <span class="Identifier">vkRegular</span><span class="Other">,</span>                <span class="Comment">## Regular variable, assigned once</span>
  <span class="Identifier">vkSequence</span><span class="Other">,</span> <span class="Identifier">vkOption</span><span class="Other">,</span> <span class="Identifier">vkSet</span><span class="Other">,</span> <span class="Identifier">vkAlt</span></pre></dt>
<dd>

Kind of matched variables

</dd>
<a id="VarSpec"></a>
<dt><pre><a href="matching.html#VarSpec"><span class="Identifier">VarSpec</span></a> <span class="Other">=</span> <span class="Keyword">object</span>
  <span class="Identifier">decl</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">NimNode</span>             <span class="Comment">## First time variable has been declared</span>
  <span class="Keyword">case</span> <span class="Identifier">varKind</span><span class="Operator">*</span><span class="Other">:</span> <a href="matching.html#VarKind"><span class="Identifier">VarKind</span></a>     <span class="Comment">## Type of the variable</span>
  <span class="Keyword">of</span> <span class="Identifier">vkAlt</span><span class="Other">:</span>
      <span class="Identifier">prefixMap</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">Table</span><span class="Other">[</span><span class="Identifier">Path</span><span class="Other">,</span> <span class="Identifier">AltSpec</span><span class="Other">]</span>

  <span class="Keyword">else</span><span class="Other">:</span>
      <span class="Keyword">nil</span>

  <span class="Identifier">typePath</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">Path</span>            <span class="Comment">## Whole path for expression that can be used to</span>
                             <span class="Comment">## determine type of the variable.</span>
  <span class="Identifier">cnt</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">int</span>                  <span class="Comment">## Number of variable occurencies in expression</span>
  </pre></dt>
<dd>



</dd>

</dl></div>
<div class="section" id="10">
<h1><a class="toc-backref" href="#10">Consts</a></h1>
<dl class="item">
<a id="nnkStrKinds"></a>
<dt><pre><a href="matching.html#nnkStrKinds"><span class="Identifier">nnkStrKinds</span></a> <span class="Other">=</span> <span class="Other">{</span><span class="DecNumber">nnkStrLit</span><span class="Other">..</span><span class="DecNumber">nnkTripleStrLit</span><span class="Other">}</span></pre></dt>
<dd>

Set of all nim node kinds for string nodes

</dd>
<a id="nnkIntKinds"></a>
<dt><pre><a href="matching.html#nnkIntKinds"><span class="Identifier">nnkIntKinds</span></a> <span class="Other">=</span> <span class="Other">{</span><span class="DecNumber">nnkCharLit</span><span class="Other">..</span><span class="DecNumber">nnkUInt64Lit</span><span class="Other">}</span></pre></dt>
<dd>

Set of all nim node kinds for integer literal nodes

</dd>
<a id="nnkFloatKinds"></a>
<dt><pre><a href="matching.html#nnkFloatKinds"><span class="Identifier">nnkFloatKinds</span></a> <span class="Other">=</span> <span class="Other">{</span><span class="DecNumber">nnkFloatLit</span><span class="Other">..</span><span class="DecNumber">nnkFloat128Lit</span><span class="Other">}</span></pre></dt>
<dd>

Set of all nim node kinds for float literal nodes

</dd>
<a id="nnkIdentKinds"></a>
<dt><pre><a href="matching.html#nnkIdentKinds"><span class="Identifier">nnkIdentKinds</span></a> <span class="Other">=</span> <span class="Other">{</span><span class="DecNumber">nnkIdent</span><span class="Other">,</span> <span class="DecNumber">nnkSym</span><span class="Other">,</span> <span class="DecNumber">nnkOpenSymChoice</span><span class="Other">}</span></pre></dt>
<dd>

Set of all nim node kinds for identifier-like nodes

</dd>
<a id="nnkTokenKinds"></a>
<dt><pre><a href="matching.html#nnkTokenKinds"><span class="Identifier">nnkTokenKinds</span></a> <span class="Other">=</span> <span class="Other">{</span><span class="DecNumber">nnkEmpty</span><span class="Other">..</span><span class="DecNumber">nnkSym</span><span class="Other">,</span> <span class="DecNumber">nnkCharLit</span><span class="Other">..</span><span class="DecNumber">nnkTripleStrLit</span><span class="Other">,</span> <span class="DecNumber">nnkOpenSymChoice</span><span class="Other">}</span></pre></dt>
<dd>

Set of all token-like nodes (primitive type literals or identifiers)

</dd>

</dl></div>
<div class="section" id="12">
<h1><a class="toc-backref" href="#12">Procs</a></h1>
<dl class="item">
<a id="addPrefix,string,string"></a>
<dt><pre><span class="Keyword">func</span> <a href="#addPrefix%2Cstring%2Cstring"><span class="Identifier">addPrefix</span></a><span class="Other">(</span><span class="Identifier">str</span><span class="Other">,</span> <span class="Identifier">pref</span><span class="Other">:</span> <span class="Identifier">string</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">string</span> <span><span class="Other">{</span><span class="Other pragmadots">...</span><span class="Other">}</span></span><span class="pragmawrap"><span class="Other">{.</span><span class="pragma"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span><span class="Other">.}</span></span></pre></dt>
<dd>



</dd>
<a id="getKindNames,NimNode"></a>
<dt><pre><span class="Keyword">proc</span> <a href="#getKindNames%2CNimNode"><span class="Identifier">getKindNames</span></a><span class="Other">(</span><span class="Identifier">head</span><span class="Other">:</span> <span class="Identifier">NimNode</span><span class="Other">)</span><span class="Other">:</span> <span class="Other">(</span><span class="Identifier">string</span><span class="Other">,</span> <span class="Identifier">seq</span><span class="Other">[</span><span class="Identifier">string</span><span class="Other">]</span><span class="Other">)</span> <span><span class="Other">{</span><span class="Other pragmadots">...</span><span class="Other">}</span></span><span class="pragmawrap"><span class="Other">{.</span><span class="pragma">
    <span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Identifier">ValueError</span><span class="Other">,</span> <span class="Identifier">KeyError</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span><span class="Other">.}</span></span></pre></dt>
<dd>



</dd>
<a id="==,FieldIndex,SomeInteger"></a>
<dt><pre><span class="Keyword">func</span> <a href="#%3D%3D%2CFieldIndex%2CSomeInteger"><span class="Identifier">`==`</span></a><span class="Other">(</span><span class="Identifier">idx</span><span class="Other">:</span> <a href="matching.html#FieldIndex"><span class="Identifier">FieldIndex</span></a><span class="Other">;</span> <span class="Identifier">i</span><span class="Other">:</span> <span class="Identifier">SomeInteger</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">bool</span></pre></dt>
<dd>



</dd>
<a id="toAccs,Path,NimNode,bool"></a>
<dt><pre><span class="Keyword">func</span> <a href="#toAccs%2CPath%2CNimNode%2Cbool"><span class="Identifier">toAccs</span></a><span class="Other">(</span><span class="Identifier">path</span><span class="Other">:</span> <span class="Identifier">Path</span><span class="Other">;</span> <span class="Identifier">name</span><span class="Other">:</span> <span class="Identifier">NimNode</span><span class="Other">;</span> <span class="Identifier">pathForType</span><span class="Other">:</span> <span class="Identifier">bool</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">NimNode</span> <span><span class="Other">{</span><span class="Other pragmadots">...</span><span class="Other">}</span></span><span class="pragmawrap"><span class="Other">{.</span><span class="pragma"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span>
    <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span><span class="Other">.}</span></span></pre></dt>
<dd>

Convert path in object to expression for getting element at path.

</dd>
<a id="parseMatchExpr,NimNode"></a>
<dt><pre><span class="Keyword">func</span> <a href="#parseMatchExpr%2CNimNode"><span class="Identifier">parseMatchExpr</span></a><span class="Other">(</span><span class="Identifier">n</span><span class="Other">:</span> <span class="Identifier">NimNode</span><span class="Other">)</span><span class="Other">:</span> <a href="matching.html#Match"><span class="Identifier">Match</span></a> <span><span class="Other">{</span><span class="Other pragmadots">...</span><span class="Other">}</span></span><span class="pragmawrap"><span class="Other">{.</span><span class="pragma"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Identifier">ValueError</span><span class="Other">,</span> <span class="Identifier">Exception</span><span class="Other">]</span><span class="Other">,</span>
    <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Identifier">RootEffect</span><span class="Other">]</span></span><span class="Other">.}</span></span></pre></dt>
<dd>

Parse match expression from nim node

</dd>
<a id="makeMatchExpr,Match,NimNode,bool,NimNode"></a>
<dt><pre><span class="Keyword">func</span> <a href="#makeMatchExpr%2CMatch%2CNimNode%2Cbool%2CNimNode"><span class="Identifier">makeMatchExpr</span></a><span class="Other">(</span><span class="Identifier">m</span><span class="Other">:</span> <a href="matching.html#Match"><span class="Identifier">Match</span></a><span class="Other">;</span> <span class="Identifier">mainExpr</span><span class="Other">:</span> <span class="Identifier">NimNode</span><span class="Other">;</span> <span class="Identifier">doRaise</span><span class="Other">:</span> <span class="Identifier">bool</span><span class="Other">;</span>
                   <span class="Identifier">originalMainExpr</span><span class="Other">:</span> <span class="Identifier">NimNode</span><span class="Other">)</span><span class="Other">:</span> <span class="Keyword">tuple</span><span class="Other">[</span><span class="Identifier">expr</span><span class="Other">:</span> <span class="Identifier">NimNode</span><span class="Other">,</span>
    <span class="Identifier">vtable</span><span class="Other">:</span> <span class="Identifier">VarTable</span><span class="Other">,</span> <span class="Identifier">mixident</span><span class="Other">:</span> <span class="Identifier">seq</span><span class="Other">[</span><span class="Identifier">string</span><span class="Other">]</span><span class="Other">]</span> <span><span class="Other">{</span><span class="Other pragmadots">...</span><span class="Other">}</span></span><span class="pragmawrap"><span class="Other">{.</span><span class="pragma">
    <span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Identifier">ValueError</span><span class="Other">,</span> <span class="Identifier">KeyError</span><span class="Other">,</span> <span class="Identifier">Exception</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Identifier">RootEffect</span><span class="Other">]</span></span><span class="Other">.}</span></span></pre></dt>
<dd>

Create NimNode for checking whether or not item referred to by <tt class="docutils literal"><span class="pre">mainExpr</span></tt> matches pattern described by <tt class="docutils literal"><span class="pre">Match</span></tt>

</dd>
<a id="kind=,NimNode,NimNodeKind"></a>
<dt><pre><span class="Keyword">func</span> <a href="#kind%3D%2CNimNode%2CNimNodeKind"><span class="Identifier">kind=</span></a><span class="Other">(</span><span class="Identifier">node</span><span class="Other">:</span> <span class="Keyword">var</span> <span class="Identifier">NimNode</span><span class="Other">;</span> <span class="Identifier">kind</span><span class="Other">:</span> <span class="Identifier">NimNodeKind</span><span class="Other">)</span> <span><span class="Other">{</span><span class="Other pragmadots">...</span><span class="Other">}</span></span><span class="pragmawrap"><span class="Other">{.</span><span class="pragma"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span><span class="Other">.}</span></span></pre></dt>
<dd>



</dd>
<a id="str,NimNode"></a>
<dt><pre><span class="Keyword">func</span> <a href="#str%2CNimNode"><span class="Identifier">str</span></a><span class="Other">(</span><span class="Identifier">node</span><span class="Other">:</span> <span class="Identifier">NimNode</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">string</span> <span><span class="Other">{</span><span class="Other pragmadots">...</span><span class="Other">}</span></span><span class="pragmawrap"><span class="Other">{.</span><span class="pragma"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Identifier">ValueError</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span><span class="Other">.}</span></span></pre></dt>
<dd>



</dd>
<a id="str=,NimNode,string"></a>
<dt><pre><span class="Keyword">func</span> <a href="#str%3D%2CNimNode%2Cstring"><span class="Identifier">str=</span></a><span class="Other">(</span><span class="Identifier">node</span><span class="Other">:</span> <span class="Keyword">var</span> <span class="Identifier">NimNode</span><span class="Other">;</span> <span class="Identifier">val</span><span class="Other">:</span> <span class="Identifier">string</span><span class="Other">)</span> <span><span class="Other">{</span><span class="Other pragmadots">...</span><span class="Other">}</span></span><span class="pragmawrap"><span class="Other">{.</span><span class="pragma"><span class="Identifier">raises</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">,</span> <span class="Identifier">tags</span><span class="Other">:</span> <span class="Other">[</span><span class="Other">]</span></span><span class="Other">.}</span></span></pre></dt>
<dd>



</dd>

</dl></div>
<div class="section" id="17">
<h1><a class="toc-backref" href="#17">Macros</a></h1>
<dl class="item">
<a id="hasKindImpl.m,typed,untyped"></a>
<dt><pre><span class="Keyword">macro</span> <a href="#hasKindImpl.m%2Ctyped%2Cuntyped"><span class="Identifier">hasKindImpl</span></a><span class="Other">(</span><span class="Identifier">head</span><span class="Other">:</span> <span class="Identifier">typed</span><span class="Other">;</span> <span class="Identifier">kind</span><span class="Other">:</span> <span class="Identifier">untyped</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">untyped</span></pre></dt>
<dd>



</dd>
<a id="expand.m,typed"></a>
<dt><pre><span class="Keyword">macro</span> <a href="#expand.m%2Ctyped"><span class="Identifier">expand</span></a><span class="Other">(</span><span class="Identifier">body</span><span class="Other">:</span> <span class="Identifier">typed</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">untyped</span></pre></dt>
<dd>



</dd>
<a id="match.m,untyped"></a>
<dt><pre><span class="Keyword">macro</span> <a href="#match.m%2Cuntyped"><span class="Identifier">match</span></a><span class="Other">(</span><span class="Identifier">n</span><span class="Other">:</span> <span class="Identifier">untyped</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">untyped</span></pre></dt>
<dd>



</dd>
<a id="assertMatch.m,untyped,untyped"></a>
<dt><pre><span class="Keyword">macro</span> <a href="#assertMatch.m%2Cuntyped%2Cuntyped"><span class="Identifier">assertMatch</span></a><span class="Other">(</span><span class="Identifier">input</span><span class="Other">,</span> <span class="Identifier">pattern</span><span class="Other">:</span> <span class="Identifier">untyped</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">untyped</span></pre></dt>
<dd>

Try to match <tt class="docutils literal"><span class="pre">input</span></tt> using <tt class="docutils literal"><span class="pre">pattern</span></tt> and raise <tt class="docutils literal"><span class="pre">MatchError</span></tt> on failure. For DSL syntax details see start of the document.

</dd>
<a id="matches.m,untyped,untyped"></a>
<dt><pre><span class="Keyword">macro</span> <a href="#matches.m%2Cuntyped%2Cuntyped"><span class="Identifier">matches</span></a><span class="Other">(</span><span class="Identifier">input</span><span class="Other">,</span> <span class="Identifier">pattern</span><span class="Other">:</span> <span class="Identifier">untyped</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">untyped</span></pre></dt>
<dd>

Try to match <tt class="docutils literal"><span class="pre">input</span></tt> using <tt class="docutils literal"><span class="pre">pattern</span></tt> and return <tt class="docutils literal"><span class="pre">false</span></tt> on failure. For DSL syntax details see start of the document.

</dd>

</dl></div>
<div class="section" id="18">
<h1><a class="toc-backref" href="#18">Templates</a></h1>
<dl class="item">
<a id="varOfIteration.t,untyped"></a>
<dt><pre><span class="Keyword">template</span> <a href="#varOfIteration.t%2Cuntyped"><span class="Identifier">varOfIteration</span></a><span class="Other">(</span><span class="Identifier">arg</span><span class="Other">:</span> <span class="Identifier">untyped</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">untyped</span></pre></dt>
<dd>



</dd>
<a id="findItFirstOpt.t,typed,untyped"></a>
<dt><pre><span class="Keyword">template</span> <a href="#findItFirstOpt.t%2Ctyped%2Cuntyped"><span class="Identifier">findItFirstOpt</span></a><span class="Other">(</span><span class="Identifier">s</span><span class="Other">:</span> <span class="Identifier">typed</span><span class="Other">;</span> <span class="Identifier">op</span><span class="Other">:</span> <span class="Identifier">untyped</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">untyped</span></pre></dt>
<dd>



</dd>
<a id="hasKind.t,untyped,untyped"></a>
<dt><pre><span class="Keyword">template</span> <a href="#hasKind.t%2Cuntyped%2Cuntyped"><span class="Identifier">hasKind</span></a><span class="Other">(</span><span class="Identifier">head</span><span class="Other">,</span> <span class="Identifier">kindExpr</span><span class="Other">:</span> <span class="Identifier">untyped</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">untyped</span></pre></dt>
<dd>

Determine if <tt class="docutils literal"><span class="pre">head</span></tt> has <tt class="docutils literal"><span class="pre">kind</span></tt> value. Either function/procedure <tt class="docutils literal"><span class="pre">kind</span></tt> or field with the same name is expected to be declared. Type of <tt class="docutils literal"><span class="pre">kind</span></tt> must be an enum. Kind expression is a pattern describing expected values. Possible examples of pattern (assuming value of type <tt class="docutils literal"><span class="pre">NimNode</span></tt> is used as <tt class="docutils literal"><span class="pre">head</span></tt>)<ul class="simple"><li><tt class="docutils literal"><span class="pre">nnkIntLit</span></tt> - match integer literal</li>
<li><tt class="docutils literal"><span class="pre">IntLit</span></tt> - alternative (preferred) syntax for matching enum values <tt class="docutils literal"><span class="pre">nnk</span></tt> prefix can be omitted.</li>
</ul>


</dd>
<a id="[].t,,static[FieldIndex]"></a>
<dt><pre><span class="Keyword">template</span> <a href="#%5B%5D.t%2C%2Cstatic%5BFieldIndex%5D"><span class="Identifier">`[]`</span></a><span class="Other">(</span><span class="Identifier">t</span><span class="Other">:</span> <span class="Keyword">tuple</span><span class="Other">;</span> <span class="Identifier">idx</span><span class="Other">:</span> <span class="Identifier">static</span><span class="Other">[</span><a href="matching.html#FieldIndex"><span class="Identifier">FieldIndex</span></a><span class="Other">]</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">untyped</span></pre></dt>
<dd>



</dd>
<a id="makeTree.t,typed,untyped"></a>
<dt><pre><span class="Keyword">template</span> <a href="#makeTree.t%2Ctyped%2Cuntyped"><span class="Identifier">makeTree</span></a><span class="Other">(</span><span class="Identifier">T</span><span class="Other">:</span> <span class="Identifier">typed</span><span class="Other">;</span> <span class="Identifier">patt</span><span class="Other">:</span> <span class="Identifier">untyped</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">untyped</span></pre></dt>
<dd>

Construct tree from pattern matching expression. For example of use see documentation at the start of the module

</dd>
<a id=":=.t,untyped,untyped"></a>
<dt><pre><span class="Keyword">template</span> <a href="#%3A%3D.t%2Cuntyped%2Cuntyped"><span class="Identifier">`:=`</span></a><span class="Other">(</span><span class="Identifier">lhs</span><span class="Other">,</span> <span class="Identifier">rhs</span><span class="Other">:</span> <span class="Identifier">untyped</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">untyped</span></pre></dt>
<dd>

Shorthand for <tt class="docutils literal"><span class="pre">assertMatch</span></tt>

</dd>
<a id="?=.t,untyped,untyped"></a>
<dt><pre><span class="Keyword">template</span> <a href="#%3F%3D.t%2Cuntyped%2Cuntyped"><span class="Identifier">`?=`</span></a><span class="Other">(</span><span class="Identifier">lhs</span><span class="Other">,</span> <span class="Identifier">rhs</span><span class="Other">:</span> <span class="Identifier">untyped</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">untyped</span></pre></dt>
<dd>

Shorthand for <tt class="docutils literal"><span class="pre">matches</span></tt>

</dd>

</dl></div>

  </div>
</div>

    <div class="row">
      <div class="twelve-columns footer">
        <span class="nim-sprite"></span>
        <br/>
        <small style="color: var(--hint);">Made with Nim. Generated: 2021-01-15 20:50:43 UTC</small>
      </div>
    </div>
  </div>
</div>

</body>
</html>
